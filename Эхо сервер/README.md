Пункты с 1 по 7 реализованы в файлах client.py и server.py 2 пункт. Клиент вводит exit и разрывает соединение
 ![image](https://user-images.githubusercontent.com/70269164/140626756-fc2533ee-7236-422b-8d30-f413d1ab517f.png)

3 пункт. Сервер продолжает слушать и можно подключиться повторно. Два клиента подключились и разорвали соединение
 ![image](https://user-images.githubusercontent.com/70269164/140626758-bd1b2db0-d619-43d3-a0d5-dc28bc7e35d9.png)

4 пункт. номер порта и имя хоста (для клиента) спрашивается у пользователя. Безопасный ввод данных реализован модулем getpass и значения по умолчанию при пустом вводе.
 ![image](https://user-images.githubusercontent.com/70269164/140626762-7bb9d45a-6a41-4bda-aff4-c39de4cacd82.png)

![image](https://user-images.githubusercontent.com/70269164/140626763-1ef1abc8-634b-4172-a2ac-751e038c3fe4.png)
 
при некорректном вводе ip или port соединение просто не установится и выведется ошибка, как таковая проверка ввода и не нужна.
5 пункт. Модифицировать код сервера таким образом, чтобы все служебные сообщения выводились не в консоль, а в специальный лог-файл. Используем модуль sys и изменяем файл вывода на наш файл.
 ![image](https://user-images.githubusercontent.com/70269164/140626767-a2fd3cd7-be10-4012-afe4-5fd89ee7fb2c.png)

![image](https://user-images.githubusercontent.com/70269164/140626769-11f8b50a-2a4d-4d98-800e-2365a14490cc.png)
 
![image](https://user-images.githubusercontent.com/70269164/140626771-73751d92-d040-4440-96f6-babb80260470.png)
 
![image](https://user-images.githubusercontent.com/70269164/140626773-6e93976a-2c06-4396-9302-aaecf7cea887.png)
 
6 пункт. Модифицируйте код сервера таким образом, чтобы он автоматически изменял номер порта, если он уже занят. Сервер должен выводить в консоль номер порта, который он слушает.
 ![image](https://user-images.githubusercontent.com/70269164/140626774-205a922a-6424-45e6-a649-4aa0bb769116.png)

![image](https://user-images.githubusercontent.com/70269164/140626776-879aa9fd-d565-45c7-8d14-ff884d6d4be1.png)
 
7 пункт. Сервер идентификации. Запросили у пользователя имя
 ![image](https://user-images.githubusercontent.com/70269164/140626779-0ff88530-c097-4038-b981-464d095a9c80.png)

Записали имя пользователя и IP в файл
 ![image](https://user-images.githubusercontent.com/70269164/140626780-3ce3c463-3986-4158-9312-c59e8d8ccea4.png)

Теперь при повторном подключении сервер нас поприветствует
 ![image](https://user-images.githubusercontent.com/70269164/140626785-e60a4588-2c10-414c-999b-69c0303cfeeb.png)

Пункты с 8 по 10 реализованы в файлах КЛИЕНТ.py и СЕРВЕР.py
8 пункт. Реализовать сервер аутентификации. Похоже на предыдущее задание, но вместе с именем пользователя сервер отслеживает и проверяет пароли. Дополнительные баллы за безопасное хранение паролей. Дополнительные баллы за поддержание сессии на основе токена наподобие cookies При первом подключении сервер попросил придумать пароль, далее он сохранил пароль и уже предложил авторизоваться, после авторизации. Пароли в файлах хранятся в хешированном виде с иcпользованием алгоритма шифрования md5. При авторизации сервер отправляет клиенту токен, который действует одну сессию, при отправке сообщения клиентом, к нему добавляется токен, сервер проверяет верен ли токен, если токен верен, сервер обрабатывает сообщение. информация о логине/пароле сохраняется в зашифрованном виде в csv файл
 ![image](https://user-images.githubusercontent.com/70269164/140626793-873235e9-5c1b-413e-b0bb-2d3d2e5c67e1.png)

![image](https://user-images.githubusercontent.com/70269164/140626795-03d67d07-2cd1-44ac-a9b1-b295a0b310cd.png)
 
![image](https://user-images.githubusercontent.com/70269164/140626798-39a36deb-154f-4b64-b714-e3e4f43c6432.png)
 
теперь сервер видит, что клиент зарегистрировался и авторизовался и может обмениваться с ним сообщениями
 ![image](https://user-images.githubusercontent.com/70269164/140626801-f41026e3-0791-4377-9bd0-01fc7a236011.png)

9 пункт. Напишите вспомогательные функции, которые реализуют отправку и принятие текстовых сообщений в сокет. Функция отправки должна дополнять сообщение заголовком фиксированной длины, в котором содержится информация о длине сообщения. Функция принятия должна читать сообщение с учетом заголовка. В дополнении реализуйте преобразование строки в байтовый массив и обратно в этих же функциях. Дополнительно оценивается, если эти функции будут реализованы как унаследованное расширение класса socket библиотеки socket.
работа отправки/ приемки сообщений приведена в пункте 8, там можно увидеть, что выводится длина сообщений, а сообщения передаются как байтовые массивы, причем вспомогательные куски на экран не выводятся. Функции реализованы отдельно и созданы как унаследованное расширение класса socket. Функции приема отправки клиента
 ![image](https://user-images.githubusercontent.com/70269164/140626802-84fcbc96-285a-4992-889b-25810e71a735.png)

Функции приема отправки сервера
![image](https://user-images.githubusercontent.com/70269164/140626806-8d5e111d-842c-4353-abee-0c6fcc75d012.png)
 
10 пункт. Дополните код клиента и сервера таким образом, чтобы они могли посылать друг другу множественные сообщения один в ответ на другое. Как видим сервер и клиент могут переписываться последовательно. Сначала сообщения сервера, потом клиента.
 ![image](https://user-images.githubusercontent.com/70269164/140626809-3a639fd0-08fc-4dfa-bf64-0d441846fe7e.png)

![image](https://user-images.githubusercontent.com/70269164/140626811-33b0671a-514a-4d4d-90c2-580f166484e4.png)
 
Если клиент отсоединится сервер будет ждать новое подключение.
 ![image](https://user-images.githubusercontent.com/70269164/140626818-78b20b87-d36b-47f4-8d8d-97fc9fa71039.png)

![image](https://user-images.githubusercontent.com/70269164/140626820-445930f5-453f-4795-84d4-f1a3998d4f92.png)
 

